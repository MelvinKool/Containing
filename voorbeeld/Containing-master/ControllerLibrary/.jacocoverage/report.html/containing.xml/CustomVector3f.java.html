<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CustomVector3f.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;ControllerLibrary&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.html" class="el_package">containing.xml</a> &gt; <span class="el_source">CustomVector3f.java</span></div><h1>CustomVector3f.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2009-2010 jMonkeyEngine
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package containing.xml;

import org.simpleframework.xml.Attribute;
import org.simpleframework.xml.Root;

/*
 * -- Added *Local methods to cut down on object creation - JS
 */
/**
 * &lt;code&gt;CustomVector3f&lt;/code&gt; defines a Vector for a three float value tuple.
 * &lt;code&gt;CustomVector3f&lt;/code&gt; can represent any three dimensional value, such
 * as a vertex, a normal, etc. Utility methods are also included to aid in
 * mathematical calculations.
 *
 * @author Mark Powell
 * @author Joshua Slack
 */
@Root
public final class CustomVector3f implements Cloneable, java.io.Serializable {

    /*   static final long serialVersionUID = 1;
    
     private static final Logger logger = Logger.getLogger(CustomVector3f.class.getName());

     public final static CustomVector3f ZERO = new CustomVector3f(0, 0, 0);
     public final static CustomVector3f NAN = new CustomVector3f(Float.NaN, Float.NaN, Float.NaN);
     public final static CustomVector3f UNIT_X = new CustomVector3f(1, 0, 0);
     public final static CustomVector3f UNIT_Y = new CustomVector3f(0, 1, 0);
     public final static CustomVector3f UNIT_Z = new CustomVector3f(0, 0, 1);
     public final static CustomVector3f UNIT_XYZ = new CustomVector3f(1, 1, 1);
     public final static CustomVector3f POSITIVE_INFINITY = new CustomVector3f(
     Float.POSITIVE_INFINITY,
     Float.POSITIVE_INFINITY,
     Float.POSITIVE_INFINITY);
     public final static CustomVector3f NEGATIVE_INFINITY = new CustomVector3f(
     Float.NEGATIVE_INFINITY,
     Float.NEGATIVE_INFINITY,
     Float.NEGATIVE_INFINITY);

     */
    /**
     * the x value of the vector.
     */
    @Attribute
    public float x;
    /**
     * the y value of the vector.
     */
    @Attribute
    public float y;
    /**
     * the z value of the vector.
     */
    @Attribute
    public float z;

    /**
     * Constructor instantiates a new
     * &lt;code&gt;CustomVector3f&lt;/code&gt; with default values of (0,0,0).
     *
     */
<span class="nc" id="L93">    public CustomVector3f() {</span>
<span class="nc" id="L94">        x = y = z = 0;</span>
<span class="nc" id="L95">    }</span>

    /**
     * Constructor instantiates a new
     * &lt;code&gt;CustomVector3f&lt;/code&gt; with provides values.
     *
     * @param x the x value of the vector.
     * @param y the y value of the vector.
     * @param z the z value of the vector.
     */
<span class="nc" id="L105">    public CustomVector3f(float x, float y, float z) {</span>
<span class="nc" id="L106">        this.x = x;</span>
<span class="nc" id="L107">        this.y = y;</span>
<span class="nc" id="L108">        this.z = z;</span>
<span class="nc" id="L109">    }</span>

    @Override
    public int hashCode() {
<span class="nc" id="L113">        int hash = 7;</span>
<span class="nc" id="L114">        hash = 19 * hash + Float.floatToIntBits(this.x);</span>
<span class="nc" id="L115">        hash = 19 * hash + Float.floatToIntBits(this.y);</span>
<span class="nc" id="L116">        hash = 19 * hash + Float.floatToIntBits(this.z);</span>
<span class="nc" id="L117">        return hash;</span>
    }

    /**
     * Constructor instantiates a new
     * &lt;code&gt;CustomVector3f&lt;/code&gt; that is a copy of the provided vector
     *
     * @param copy The CustomVector3f to copy
     */
<span class="nc" id="L126">    public CustomVector3f(CustomVector3f copy) {</span>
<span class="nc" id="L127">        this.set(copy);</span>
<span class="nc" id="L128">    }</span>

    /**
     * &lt;code&gt;set&lt;/code&gt; sets the x,y,z values of the vector based on passed
     * parameters.
     *
     * @param x the x value of the vector.
     * @param y the y value of the vector.
     * @param z the z value of the vector.
     * @return this vector
     */
    public CustomVector3f set(float x, float y, float z) {
<span class="nc" id="L140">        this.x = x;</span>
<span class="nc" id="L141">        this.y = y;</span>
<span class="nc" id="L142">        this.z = z;</span>
<span class="nc" id="L143">        return this;</span>
    }

    /**
     * &lt;code&gt;set&lt;/code&gt; sets the x,y,z values of the vector by copying the
     * supplied vector.
     *
     * @param vect the vector to copy.
     * @return this vector
     */
    public CustomVector3f set(CustomVector3f vect) {
<span class="nc" id="L154">        this.x = vect.x;</span>
<span class="nc" id="L155">        this.y = vect.y;</span>
<span class="nc" id="L156">        this.z = vect.z;</span>
<span class="nc" id="L157">        return this;</span>
    }


    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L164">            return false;</span>
        }
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L167">            return false;</span>
        }
<span class="nc" id="L169">        final CustomVector3f other = (CustomVector3f) obj;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (Float.floatToIntBits(this.x) != Float.floatToIntBits(other.x)) {</span>
<span class="nc" id="L171">            return false;</span>
        }
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (Float.floatToIntBits(this.y) != Float.floatToIntBits(other.y)) {</span>
<span class="nc" id="L174">            return false;</span>
        }
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (Float.floatToIntBits(this.z) != Float.floatToIntBits(other.z)) {</span>
<span class="nc" id="L177">            return false;</span>
        }
<span class="nc" id="L179">        return true;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L184">        return &quot;Vector3f{&quot; + &quot;x=&quot; + x + &quot;, y=&quot; + y + &quot;, z=&quot; + z + '}';</span>
    }
    /**
     *
     * &lt;code&gt;add&lt;/code&gt; adds a provided vector to this vector creating a
     * resultant vector which is returned. If the provided vector is null, null
     * is returned.
     *
     * @param vec the vector to add to this.
     * @return the resultant vector.
     */
    /*  public CustomVector3f add(CustomVector3f vec) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, null returned.&quot;);
     return null;
     }
     return new CustomVector3f(x + vec.x, y + vec.y, z + vec.z);
     }

     /**
     *
     * &lt;code&gt;add&lt;/code&gt; adds the values of a provided vector storing the
     * values in the supplied vector.
     *
     * @param vec
     *            the vector to add to this
     * @param result
     *            the vector to store the result in
     * @return result returns the supplied result vector.
     */
    /*   public CustomVector3f add(CustomVector3f vec, CustomVector3f result) {
     result.x = x + vec.x;
     result.y = y + vec.y;
     result.z = z + vec.z;
     return result;
     }

     /**
     * &lt;code&gt;addLocal&lt;/code&gt; adds a provided vector to this vector internally,
     * and returns a handle to this vector for easy chaining of calls. If the
     * provided vector is null, null is returned.
     *
     * @param vec
     *            the vector to add to this vector.
     * @return this
     */
    /*  public CustomVector3f addLocal(CustomVector3f vec) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, null returned.&quot;);
     return null;
     }
     x += vec.x;
     y += vec.y;
     z += vec.z;
     return this;
     }

     /**
     *
     * &lt;code&gt;add&lt;/code&gt; adds the provided values to this vector, creating a
     * new vector that is then returned.
     *
     * @param addX
     *            the x value to add.
     * @param addY
     *            the y value to add.
     * @param addZ
     *            the z value to add.
     * @return the result vector.
     */
    /*  public CustomVector3f add(float addX, float addY, float addZ) {
     return new CustomVector3f(x + addX, y + addY, z + addZ);
     }

     /**
     * &lt;code&gt;addLocal&lt;/code&gt; adds the provided values to this vector
     * internally, and returns a handle to this vector for easy chaining of
     * calls.
     *
     * @param addX
     *            value to add to x
     * @param addY
     *            value to add to y
     * @param addZ
     *            value to add to z
     * @return this
     */
    /*public CustomVector3f addLocal(float addX, float addY, float addZ) {
     x += addX;
     y += addY;
     z += addZ;
     return this;
     }

     /**
     *
     * &lt;code&gt;scaleAdd&lt;/code&gt; multiplies this vector by a scalar then adds the
     * given CustomVector3f.
     *
     * @param scalar
     *            the value to multiply this vector by.
     * @param add
     *            the value to add
     */
    /*  public CustomVector3f scaleAdd(float scalar, CustomVector3f add) {
     x = x * scalar + add.x;
     y = y * scalar + add.y;
     z = z * scalar + add.z;
     return this;
     }

     /**
     *
     * &lt;code&gt;scaleAdd&lt;/code&gt; multiplies the given vector by a scalar then adds
     * the given vector.
     *
     * @param scalar
     *            the value to multiply this vector by.
     * @param mult
     *            the value to multiply the scalar by
     * @param add
     *            the value to add
     */
    /* public CustomVector3f scaleAdd(float scalar, CustomVector3f mult, CustomVector3f add) {
     this.x = mult.x * scalar + add.x;
     this.y = mult.y * scalar + add.y;
     this.z = mult.z * scalar + add.z;
     return this;
     }

     /**
     *
     * &lt;code&gt;dot&lt;/code&gt; calculates the dot product of this vector with a
     * provided vector. If the provided vector is null, 0 is returned.
     *
     * @param vec
     *            the vector to dot with this vector.
     * @return the resultant dot product of this vector and a given vector.
     */
    /* public float dot(CustomVector3f vec) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, 0 returned.&quot;);
     return 0;
     }
     return x * vec.x + y * vec.y + z * vec.z;
     }

     /**
     * &lt;code&gt;cross&lt;/code&gt; calculates the cross product of this vector with a
     * parameter vector v.
     *
     * @param v
     *            the vector to take the cross product of with this.
     * @return the cross product vector.
     */
    /*  public CustomVector3f cross(CustomVector3f v) {
     return cross(v, null);
     }

     /**
     * &lt;code&gt;cross&lt;/code&gt; calculates the cross product of this vector with a
     * parameter vector v.  The result is stored in &lt;code&gt;result&lt;/code&gt;
     *
     * @param v
     *            the vector to take the cross product of with this.
     * @param result
     *            the vector to store the cross product result.
     * @return result, after recieving the cross product vector.
     */
    /*  public CustomVector3f cross(CustomVector3f v,CustomVector3f result) {
     return cross(v.x, v.y, v.z, result);
     }

     /**
     * &lt;code&gt;cross&lt;/code&gt; calculates the cross product of this vector with a
     * parameter vector v.  The result is stored in &lt;code&gt;result&lt;/code&gt;
     *
     * @param otherX
     *            x component of the vector to take the cross product of with this.
     * @param otherY
     *            y component of the vector to take the cross product of with this.
     * @param otherZ
     *            z component of the vector to take the cross product of with this.
     * @param result
     *            the vector to store the cross product result.
     * @return result, after recieving the cross product vector.
     */
    /* public CustomVector3f cross(float otherX, float otherY, float otherZ, CustomVector3f result) {
     if (result == null) result = new CustomVector3f();
     float resX = ((y * otherZ) - (z * otherY)); 
     float resY = ((z * otherX) - (x * otherZ));
     float resZ = ((x * otherY) - (y * otherX));
     result.set(resX, resY, resZ);
     return result;
     }

     /**
     * &lt;code&gt;crossLocal&lt;/code&gt; calculates the cross product of this vector
     * with a parameter vector v.
     *
     * @param v
     *            the vector to take the cross product of with this.
     * @return this.
     */
    /*  public CustomVector3f crossLocal(CustomVector3f v) {
     return crossLocal(v.x, v.y, v.z);
     }

     /**
     * &lt;code&gt;crossLocal&lt;/code&gt; calculates the cross product of this vector
     * with a parameter vector v.
     *
     * @param otherX
     *            x component of the vector to take the cross product of with this.
     * @param otherY
     *            y component of the vector to take the cross product of with this.
     * @param otherZ
     *            z component of the vector to take the cross product of with this.
     * @return this.
     */
    /* public CustomVector3f crossLocal(float otherX, float otherY, float otherZ) {
     float tempx = ( y * otherZ ) - ( z * otherY );
     float tempy = ( z * otherX ) - ( x * otherZ );
     z = (x * otherY) - (y * otherX);
     x = tempx;
     y = tempy;
     return this;
     }

     /*   public CustomVector3f project(CustomVector3f other){
     float n = this.dot(other); // A . B
     float d = other.lengthSquared(); // |B|^2
     return new CustomVector3f(other).normalizeLocal().multLocal(n/d);
     }*/
    /**
     * Returns true if this vector is a unit vector (length() ~= 1), returns
     * false otherwise.
     *
     * @return true if this vector is a unit vector (length() ~= 1), or false
     * otherwise.
     */
    /*   public boolean isUnitVector(){
     float len = length();
     * return 0.99f &lt; len &amp;&amp; len &lt; 1.01f;
     }
     */
    /**
     * &lt;code&gt;length&lt;/code&gt; calculates the magnitude of this vector.
     *
     * @return the length or magnitude of the vector.
     */
    /*   public float length() {
     return FastMath.sqrt(lengthSquared());
     }*/
    /**
     * &lt;code&gt;lengthSquared&lt;/code&gt; calculates the squared value of the magnitude
     * of the vector.
     *
     * @return the magnitude squared of the vector.
     */
    /*  public float lengthSquared() {
     return x * x + y * y + z * z;
     }

     /**
     * &lt;code&gt;distanceSquared&lt;/code&gt; calculates the distance squared between
     * this vector and vector v.
     *
     * @param v the second vector to determine the distance squared.
     * @return the distance squared between the two vectors.
     */
    /*  public float distanceSquared(CustomVector3f v) {
     double dx = x - v.x;
     double dy = y - v.y;
     double dz = z - v.z;
     return (float) (dx * dx + dy * dy + dz * dz);
     }

     /**
     * &lt;code&gt;distance&lt;/code&gt; calculates the distance between this vector and
     * vector v.
     *
     * @param v the second vector to determine the distance.
     * @return the distance between the two vectors.
     */
    /*  public float distance(CustomVector3f v) {
     return FastMath.sqrt(distanceSquared(v));
     }*/
    /**
     *
     * &lt;code&gt;mult&lt;/code&gt; multiplies this vector by a scalar. The resultant
     * vector is returned.
     *
     * @param scalar the value to multiply this vector by.
     * @return the new vector.
     */
    /* public CustomVector3f mult(float scalar) {
     return new CustomVector3f(x * scalar, y * scalar, z * scalar);
     }

     /**
     *
     * &lt;code&gt;mult&lt;/code&gt; multiplies this vector by a scalar. The resultant
     * vector is supplied as the second parameter and returned.
     *
     * @param scalar the scalar to multiply this vector by.
     * @param product the product to store the result in.
     * @return product
     */
    /*  public CustomVector3f mult(float scalar, CustomVector3f product) {
     if (null == product) {
     product = new CustomVector3f();
     }

     product.x = x * scalar;
     product.y = y * scalar;
     product.z = z * scalar;
     return product;
     }

     /**
     * &lt;code&gt;multLocal&lt;/code&gt; multiplies this vector by a scalar internally,
     * and returns a handle to this vector for easy chaining of calls.
     *
     * @param scalar
     *            the value to multiply this vector by.
     * @return this
     */
    /*  public CustomVector3f multLocal(float scalar) {
     x *= scalar;
     y *= scalar;
     z *= scalar;
     return this;
     }

     /**
     * &lt;code&gt;multLocal&lt;/code&gt; multiplies a provided vector to this vector
     * internally, and returns a handle to this vector for easy chaining of
     * calls. If the provided vector is null, null is returned.
     *
     * @param vec
     *            the vector to mult to this vector.
     * @return this
     */
    /* public CustomVector3f multLocal(CustomVector3f vec) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, null returned.&quot;);
     return null;
     }
     x *= vec.x;
     y *= vec.y;
     z *= vec.z;
     return this;
     }

     /**
     * &lt;code&gt;multLocal&lt;/code&gt; multiplies this vector by 3 scalars
     * internally, and returns a handle to this vector for easy chaining of
     * calls.
     *
     * @param x
     * @param y
     * @param z
     * @return this
     */
    /*public CustomVector3f multLocal(float x, float y, float z) {
     this.x *= x;
     this.y *= y;
     this.z *= z;
     return this;
     }

     /**
     * &lt;code&gt;multLocal&lt;/code&gt; multiplies a provided vector to this vector
     * internally, and returns a handle to this vector for easy chaining of
     * calls. If the provided vector is null, null is returned.
     *
     * @param vec
     *            the vector to mult to this vector.
     * @return this
     */
    /* public CustomVector3f mult(CustomVector3f vec) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, null returned.&quot;);
     return null;
     }
     return mult(vec, null);
     }

     /**
     * &lt;code&gt;multLocal&lt;/code&gt; multiplies a provided vector to this vector
     * internally, and returns a handle to this vector for easy chaining of
     * calls. If the provided vector is null, null is returned.
     *
     * @param vec
     *            the vector to mult to this vector.
     * @param store result vector (null to create a new vector)
     * @return this
     */
    /* public CustomVector3f mult(CustomVector3f vec, CustomVector3f store) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, null returned.&quot;);
     return null;
     }
     if (store == null) store = new CustomVector3f();
     return store.set(x * vec.x, y * vec.y, z * vec.z);
     }


     /**
     * &lt;code&gt;divide&lt;/code&gt; divides the values of this vector by a scalar and
     * returns the result. The values of this vector remain untouched.
     *
     * @param scalar
     *            the value to divide this vectors attributes by.
     * @return the result &lt;code&gt;Vector&lt;/code&gt;.
     */
    /* public CustomVector3f divide(float scalar) {
     scalar = 1f/scalar;
     return new CustomVector3f(x * scalar, y * scalar, z * scalar);
     }

     /**
     * &lt;code&gt;divideLocal&lt;/code&gt; divides this vector by a scalar internally,
     * and returns a handle to this vector for easy chaining of calls. Dividing
     * by zero will result in an exception.
     *
     * @param scalar
     *            the value to divides this vector by.
     * @return this
     */
    /* public CustomVector3f divideLocal(float scalar) {
     scalar = 1f/scalar;
     x *= scalar;
     y *= scalar;
     z *= scalar;
     return this;
     }


     /**
     * &lt;code&gt;divide&lt;/code&gt; divides the values of this vector by a scalar and
     * returns the result. The values of this vector remain untouched.
     *
     * @param scalar
     *            the value to divide this vectors attributes by.
     * @return the result &lt;code&gt;Vector&lt;/code&gt;.
     */
    /*  public CustomVector3f divide(CustomVector3f scalar) {
     return new CustomVector3f(x / scalar.x, y / scalar.y, z / scalar.z);
     }

     /**
     * &lt;code&gt;divideLocal&lt;/code&gt; divides this vector by a scalar internally,
     * and returns a handle to this vector for easy chaining of calls. Dividing
     * by zero will result in an exception.
     *
     * @param scalar
     *            the value to divides this vector by.
     * @return this
     */
    /*  public CustomVector3f divideLocal(CustomVector3f scalar) {
     x /= scalar.x;
     y /= scalar.y;
     z /= scalar.z;
     return this;
     }

     /**
     *
     * &lt;code&gt;negate&lt;/code&gt; returns the negative of this vector. All values are
     * negated and set to a new vector.
     *
     * @return the negated vector.
     */
    /*   public CustomVector3f negate() {
     return new CustomVector3f(-x, -y, -z);
     }

     /**
     *
     * &lt;code&gt;negateLocal&lt;/code&gt; negates the internal values of this vector.
     *
     * @return this.
     */
    /*   public CustomVector3f negateLocal() {
     /        x = -x;
     y = -y;
     z = -z;
     return this;
     }

     /**
     *
     * &lt;code&gt;subtract&lt;/code&gt; subtracts the values of a given vector from those
     * of this vector creating a new vector object. If the provided vector is
     * null, null is returned.
     *
     * @param vec
     *            the vector to subtract from this vector.
     * @return the result vector.
     */
    /*  public CustomVector3f subtract(CustomVector3f vec) {
     return new CustomVector3f(x - vec.x, y - vec.y, z - vec.z);
     }

     /**
     * &lt;code&gt;subtractLocal&lt;/code&gt; subtracts a provided vector to this vector
     * internally, and returns a handle to this vector for easy chaining of
     * calls. If the provided vector is null, null is returned.
     *
     * @param vec
     *            the vector to subtract
     * @return this
     */
    /*   public CustomVector3f subtractLocal(CustomVector3f vec) {
     if (null == vec) {
     logger.warning(&quot;Provided vector is null, null returned.&quot;);
     return null;
     }
     x -= vec.x;
     y -= vec.y;
     z -= vec.z;
     return this;
     }

     /**
     *
     * &lt;code&gt;subtract&lt;/code&gt;
     *
     * @param vec
     *            the vector to subtract from this
     * @param result
     *            the vector to store the result in
     * @return result
     */
    /*  public CustomVector3f subtract(CustomVector3f vec, CustomVector3f result) {
     if(result == null) {
     result = new CustomVector3f();
     }
     result.x = x - vec.x;
     result.y = y - vec.y;
     result.z = z - vec.z;
     return result;
     }

     /**
     *
     * &lt;code&gt;subtract&lt;/code&gt; subtracts the provided values from this vector,
     * creating a new vector that is then returned.
     *
     * @param subtractX
     *            the x value to subtract.
     * @param subtractY
     *            the y value to subtract.
     * @param subtractZ
     *            the z value to subtract.
     * @return the result vector.
     */
    /*  public CustomVector3f subtract(float subtractX, float subtractY, float subtractZ) {
     return new CustomVector3f(x - subtractX, y - subtractY, z - subtractZ);
     }

     /**
     * &lt;code&gt;subtractLocal&lt;/code&gt; subtracts the provided values from this vector
     * internally, and returns a handle to this vector for easy chaining of
     * calls.
     *
     * @param subtractX
     *            the x value to subtract.
     * @param subtractY
     *            the y value to subtract.
     * @param subtractZ
     *            the z value to subtract.
     * @return this
     */
    /*  public CustomVector3f subtractLocal(float subtractX, float subtractY, float subtractZ) {
     x -= subtractX;
     y -= subtractY;
     z -= subtractZ;
     return this;
     }

     /**
     * &lt;code&gt;normalize&lt;/code&gt; returns the unit vector of this vector.
     *
     * @return unit vector of this vector.
     */
    /* public CustomVector3f normalize() {
     //        float length = length();
     //        if (length != 0) {
     //            return divide(length);
     //        }
     //
     //        return divide(1);
     float length = x * x + y * y + z * z;
     if (length != 1f &amp;&amp; length != 0f){
     length = 1.0f / FastMath.sqrt(length);
     return new CustomVector3f(x * length, y * length, z * length);
     }
     return clone();
     }*/
    /**
     * &lt;code&gt;normalizeLocal&lt;/code&gt; makes this vector into a unit vector of
     * itself.
     *
     * @return this.
     */
    /*  public CustomVector3f normalizeLocal() {
     // NOTE: this implementation is more optimized
     // than the old jme normalize as this method
     // is commonly used.
     float length = x * x + y * y + z * z;
     if (length != 1f &amp;&amp; length != 0f){
     length = 1.0f / FastMath.sqrt(length);
     x *= length;
     y *= length;
     z *= length;
     }
     return this;
     }*/
    /**
     * &lt;code&gt;maxLocal&lt;/code&gt; computes the maximum value for each component in
     * this and
     * &lt;code&gt;other&lt;/code&gt; vector. The result is stored in this vector.
     *
     * @param other
     */
    /*   public void maxLocal(CustomVector3f other){
     x = other.x &gt; x ? other.x : x;
     y = other.y &gt; y ? other.y : y;
     z = other.z &gt; z ? other.z : z;
     }

     /**
     * &lt;code&gt;minLocal&lt;/code&gt; computes the minimum value for each
     * component in this and &lt;code&gt;other&lt;/code&gt; vector. The result is stored
     * in this vector.
     * @param other
     */
    /*  public void minLocal(CustomVector3f other){
     x = other.x &lt; x ? other.x : x;
     y = other.y &lt; y ? other.y : y;
     z = other.z &lt; z ? other.z : z;
     }

     /**
     * &lt;code&gt;zero&lt;/code&gt; resets this vector's data to zero internally.
     */
    /* public CustomVector3f zero() {
     x = y = z = 0;
     return this;
     }

     /**
     * &lt;code&gt;angleBetween&lt;/code&gt; returns (in radians) the angle between two vectors.
     * It is assumed that both this vector and the given vector are unit vectors (iow, normalized).
     * 
     * @param otherVector a unit vector to find the angle against
     * @return the angle in radians.
     */
    // public float angleBetween(CustomVector3f otherVector) {
    //    float dotProduct = dot(otherVector);
    // float angle = FastMath.acos(dotProduct);
    // }
    /**
     * Sets this vector to the interpolation by changeAmnt from this to the
     * finalVec this=(1-changeAmnt)*this + changeAmnt * finalVec
     *
     * @param finalVec The final vector to interpolate towards
     * @param changeAmnt An amount between 0.0 - 1.0 representing a precentage
     * change from this towards finalVec
     */
    /*  public CustomVector3f interpolate(CustomVector3f finalVec, float changeAmnt) {
     this.x=(1-changeAmnt)*this.x + changeAmnt*finalVec.x;
     this.y=(1-changeAmnt)*this.y + changeAmnt*finalVec.y;
     this.z=(1-changeAmnt)*this.z + changeAmnt*finalVec.z;
     return this;
     }

     /**
     * Sets this vector to the interpolation by changeAmnt from beginVec to finalVec
     * this=(1-changeAmnt)*beginVec + changeAmnt * finalVec
     * @param beginVec the beging vector (changeAmnt=0)
     * @param finalVec The final vector to interpolate towards
     * @param changeAmnt An amount between 0.0 - 1.0 representing a precentage
     *  change from beginVec towards finalVec
     */
    /*  public CustomVector3f interpolate(CustomVector3f beginVec,CustomVector3f finalVec, float changeAmnt) {
     this.x=(1-changeAmnt)*beginVec.x + changeAmnt*finalVec.x;
     this.y=(1-changeAmnt)*beginVec.y + changeAmnt*finalVec.y;
     this.z=(1-changeAmnt)*beginVec.z + changeAmnt*finalVec.z;
     return this;
     }

     /**
     * Check a vector... if it is null or its floats are NaN or infinite,
     * return false.  Else return true.
     * @param vector the vector to check
     * @return true or false as stated above.
     */
    /* public static boolean isValidVector(CustomVector3f vector) {
     if (vector == null) return false;
     if (Float.isNaN(vector.x) ||
     Float.isNaN(vector.y) ||
     Float.isNaN(vector.z)) return false;
     if (Float.isInfinite(vector.x) ||
     Float.isInfinite(vector.y) ||
     Float.isInfinite(vector.z)) return false;
     return true;
     }

     /*  public static void generateOrthonormalBasis(CustomVector3f u, CustomVector3f v, CustomVector3f w) {
     w.normalizeLocal();
     generateComplementBasis(u, v, w);
     }

     public static void generateComplementBasis(CustomVector3f u, CustomVector3f v,
     CustomVector3f w) {
     float fInvLength;

     if (FastMath.abs(w.x) &gt;= FastMath.abs(w.y)) {
     // w.x or w.z is the largest magnitude component, swap them
     fInvLength = FastMath.invSqrt(w.x * w.x + w.z * w.z);
     u.x = -w.z * fInvLength;
     u.y = 0.0f;
     u.z = +w.x * fInvLength;
     v.x = w.y * u.z;
     v.y = w.z * u.x - w.x * u.z;
     v.z = -w.y * u.x;
     } else {
     // w.y or w.z is the largest magnitude component, swap them
     fInvLength = FastMath.invSqrt(w.y * w.y + w.z * w.z);
     u.x = 0.0f;
     u.y = +w.z * fInvLength;
     u.z = -w.y * fInvLength;
     v.x = w.y * u.z - w.z * u.y;
     v.y = -w.x * u.z;
     v.z = w.x * u.y;
     }
     }

     @Override
     public CustomVector3f clone() {
     try {
     return (CustomVector3f) super.clone();
     } catch (CloneNotSupportedException e) {
     throw new AssertionError(); // can not happen
     }
     }

     /**
     * Saves this CustomVector3f into the given float[] object.
     * 
     * @param floats
     *            The float[] to take this CustomVector3f. If null, a new float[3] is
     *            created.
     * @return The array, with X, Y, Z float values in that order
     */
    /*   public float[] toArray(float[] floats) {
     if (floats == null) {
     floats = new float[3];
     }
     floats[0] = x;
     floats[1] = y;
     floats[2] = z;
     return floats;
     }

     /**
     * are these two vectors the same? they are is they both have the same x,y,
     * and z values.
     *
     * @param o
     *            the object to compare for equality
     * @return true if they are equal
     */
    /*  public boolean equals(Object o) {
     if (!(o instanceof CustomVector3f)) { return false; }

     if (this == o) { return true; }

     CustomVector3f comp = (CustomVector3f) o;
     if (Float.compare(x,comp.x) != 0) return false;
     if (Float.compare(y,comp.y) != 0) return false;
     if (Float.compare(z,comp.z) != 0) return false;
     return true;
     }

     /**
     * &lt;code&gt;hashCode&lt;/code&gt; returns a unique code for this vector object based
     * on it's values. If two vectors are logically equivalent, they will return
     * the same hash code value.
     * @return the hash code value of this vector.
     */
    /*  public int hashCode() {
     int hash = 37;
     hash += 37 * hash + Float.floatToIntBits(x);
     hash += 37 * hash + Float.floatToIntBits(y);
     hash += 37 * hash + Float.floatToIntBits(z);
     return hash;
     }

     /**
     * &lt;code&gt;toString&lt;/code&gt; returns the string representation of this vector.
     * The format is:
     *
     * org.jme.math.CustomVector3f [X=XX.XXXX, Y=YY.YYYY, Z=ZZ.ZZZZ]
     *
     * @return the string representation of this vector.
     */
    /* public String toString() {
     return &quot;(&quot; + x + &quot;, &quot; + y + &quot;, &quot; + z + &quot;)&quot;;
     }

     /*   public void write(JmeExporter e) throws IOException {
     OutputCapsule capsule = e.getCapsule(this);
     capsule.write(x, &quot;x&quot;, 0);
     capsule.write(y, &quot;y&quot;, 0);
     capsule.write(z, &quot;z&quot;, 0);
     }

     public void read(JmeImporter e) throws IOException {
     InputCapsule capsule = e.getCapsule(this);
     x = capsule.readFloat(&quot;x&quot;, 0);
     y = capsule.readFloat(&quot;y&quot;, 0);
     z = capsule.readFloat(&quot;z&quot;, 0);
     }
     */
    /*   public float getX() {
     return x;
     }

     public CustomVector3f setX(float x) {
     this.x = x;
     return this;
     }

     public float getY() {
     return y;
     }

     public CustomVector3f setY(float y) {
     this.y = y;
     return this;
     }

     public float getZ() {
     return z;
     }

     public CustomVector3f setZ(float z) {
     this.z = z;
     return this;
     }
    
     /**
     * @param index
     * @return x value if index == 0, y value if index == 1 or z value if index ==
     *         2
     * @throws IllegalArgumentException
     *             if index is not one of 0, 1, 2.
     */
    /* public float get(int index) {
     switch (index) {
     case 0:
     return x;
     case 1:
     return y;
     case 2:
     return z;
     }
     throw new IllegalArgumentException(&quot;index must be either 0, 1 or 2&quot;);
     }
    
     /**
     * @param index
     *            which field index in this vector to set.
     * @param value
     *            to set to one of x, y or z.
     * @throws IllegalArgumentException
     *             if index is not one of 0, 1, 2.
     */
    /*  public void set(int index, float value) {
     switch (index) {
     case 0:
     x = value;
     return;
     case 1:
     y = value;
     return;
     case 2:
     z = value;
     return;
     }
     throw new IllegalArgumentException(&quot;index must be either 0, 1 or 2&quot;);
     }*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>